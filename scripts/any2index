#!/usr/bin/env perl 

use warnings;
use strict;
use Data::Dumper;
use Getopt::Long;
use File::Basename qw/basename/;
use Bio::Tools::GuessSeqFormat ();
use File::Which qw/which/;
use FindBin qw/$RealBin/;
use lib "$RealBin/../lib/perl5";

our $VERSION = 0.3;

# An array of methods for indexing. Each method is a hash.
# For each individual method, required keys are
#   * name    => unique name for method
#   * format  => file format, e.g., fasta
#   * command => the linux command. __FILE__ for infile
#   * help    => description
#   * querying=> description on how to query this index
my @requiredMethodKey = qw(name format command help querying);
my @indexes = (
  {
    name    => "samtoolsFaidx",
    format  => "fasta",
    command => "samtools faidx __FILE__",
    help    => "Indexes for the samtools package",
    querying=> "samtools faidx __FILE__ contig:start-stop",
  },
  {
    name    => "bowtie2Build",
    format  => "fasta",
    command => "bowtie2-build __FILE__ __FILE__",
    help    => "Indexes for bowtie2",
    querying=> "bowtie2 -x __FILE__ -p __THREADS__ -1 R1.fastq.gz -2 R2.fastq.gz > out.sam",
  },
  {
    name    => "makeBlastDb",
    format  => "fasta",
    command => "makeblastdb -in __FILE__ -dbtype nucl -parse_seqids",
    help    => "Indexes BLASTn",
    querying=> "blastn -in __FILE__ -query QUERY.fasta",
  },
  {
    name    => "samtoolsIndex",
    format  => "bam",
    command => "samtools index __FILE__",
    help    => "Indexes a bam for samtools",
    querying=> "samtools view __FILE__",
  },
);

# Ensure the integrity of the indexing hash
sub sanityCheckOnIndexMethods{
  my($settings) = @_;

  for my $method (@indexes){
    # Check for required keys
    for my $key(@requiredMethodKey){
      if(!$$method{$key}){
        die "ERROR: indexing hash does not have a $key key:\n".Dumper($method);
      }
    }
  }
}


local $0 = basename $0;
sub logmsg{local $0=basename $0; print STDERR "$0: @_\n";}

# Check executables
sub checkEnv{
  for my $exe(qw(samtools)){
    which($exe) or logmsg "WARNING: could not find $exe in your path";
  }
}

exit(main());

sub main{
  my $settings={};
  GetOptions($settings,qw(help help-with=s nocheck list dryrun|dry-run version)) or die $!;
  usage() if($$settings{help});

  # By default, check dependencies. Users might not want
  # to check all dependencies and so they can stop it
  # with --nocheck
  if(defined($$settings{nocheck})){
    checkEnv();
  }
  if($$settings{version}){
    print "$0 v$VERSION\n";
    return 0;
  }

  sanityCheckOnIndexMethods($settings);

  if($$settings{list}){
    listIndexers($settings);
    return 0;
  }
  if($$settings{'help-with'}){
    indexerHelp($$settings{'help-with'}, $settings);
    return 0;
  }

  # Check for argv if we aren't running any special commands
  usage() if(!@ARGV);

  my $guesser = Bio::Tools::GuessSeqFormat->new();

  for my $infile(@ARGV){
    if(-d $infile){
      logmsg "SKIP: directory $infile";
      next;
    }
    logmsg "FILE: $infile";

    # Guess the file format
    $guesser->file($infile);
    # ... but don't spin wheels on things we can't index
    my $format = $guesser->guess;
    if(!$format || $format eq 'raw'){
      logmsg "SKIP: I do not understand format for $infile";
      next;
    }

    indexTheFile($infile, $format, $settings);

  }

  return 0;
}

# Run the indexers on the file
sub indexTheFile{
  my($infile, $format, $settings) = @_;
  # Run the index commands
  for my $method (sort grep{$$_{format} eq $format} @indexes){
    my $command = $$method{command};

    # Replace any resrved words and evaluate them
    $command =~ s/__FILE__/'$infile'/g;

    if($$settings{'dryrun'}){
      print "# COMMAND\n  $command\n";
    } else {
      my $failed = system($command.">/dev/null 2>&1");
      if($failed){
        die "ERROR with running $command: $!\n  Error on $infile and $$method{name}";
      }
    }
  }
}

# Print a pretty table for different indexing methods
sub listIndexers{
  my($settings) = @_;

  print join("\t", qw(name format help))."\n";
  for my $m (sort {$$a{name} cmp $$b{name}} @indexes){
    print join("\t", $$m{name}, $$m{format}, $$m{help})."\n";
  }
}

# Give in-depth help on an indexing method
sub indexerHelp{
  my($indexerName, $settings) = @_;
  
  for my $m(@indexes){
    if($indexerName =~ /^$$m{name}$/i){
      print "$$m{name}: for $$m{format} files.\n";
      print "  $$m{help}\n";
      print "Method: $$m{command}\n";
      print "Querying: $$m{querying}\n";
      return 1;
    }
  }

  die "ERROR: I do not understand $indexerName indexer. Run $0 --list for names.";
}

sub usage{
  print "$0: indexes any bioinformatics file appropriately
  Usage: $0 [options] file.ext
  --list       List all the possible indexers
  --nocheck    Do not check dependencies
  --dry-run    Print the commands to stdout and do not execute
  --help-with  Give more help on a particular indexer
  --help       This useful help menu
  --version
";
  exit 0;
}

